{"version":3,"file":"query.js","sourceRoot":"","sources":["query.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,EAAE,KAAK,EAAE,MAAM,YAAY,CAAC;AAOnC,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;AAElC;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,MAAM,UAAU,KAAK,CAAC,OAAsB;IAE3C,OAAO,CACN,KAAY,EACZ,IAAiB,EAChB,EAAE;QACH,MAAM,UAAU,GAAG,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QAChE,IAAI,CAAC,UAAU,EAAE;YAChB,MAAM,IAAI,KAAK,CAAC,4DAA4D,CAAC,CAAA;SAC7E;QACD,MAAM,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,WAA2B,CAAC;QACjD,MAAM,SAAS,GAAW,GAAG,OAAO,EAAE,SAAS,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;QAClE,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC9C,MAAM,IAAI,GAAG,UAAU,EAAE,IAAI,CAAA;QAC7B,IAAI,UAAU,EAAE;YACf,MAAM,aAAa,GAAG,UAAU,CAAC,YAAY,CAAA;YAC7C,MAAM,cAAc,GAAG,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;YAEtD,mEAAmE;YACnE,IAAI,cAAc,KAAK,IAAI,EAAE;gBAC5B,UAAU,CAAC,SAAS,GAAG,IAAI,CAAA;aAC3B;YACD,UAAU,CAAC,YAAY,GAAG,GAAG,EAAE,CAAC,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,aAAa,CAAC,aAAa,CAAC,CAAC;YAC5F,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,GAAG,UAAU,EAAE,GAAG,OAAO,EAAE,CAAC,CAAA;YAEzD,OAAO,SAAS,CAAA;SAEhB;QACD,OAAO,SAAS,CAAA;IACjB,CAAC,CAAA;AAEF,CAAC","sourcesContent":["\nimport { State } from '../state.js'\nimport { functionValue } from '../functionValue.js';\nimport { parse } from './parse.js';\n\nexport type QueryOptions = {\n\tparameter?: string,\n\tskipAsync?: boolean\n}\n\nconst url = new URL(location.href)\n\n/**\n * A decorator for setting state values from url parameters\n * \n * Used together with @storage, it allows to persist such values. \n * @query must be placed before @storage for this to work.\n * \n *  * How to use: \n * ```js\n * class MyState extends State {\n * \t\n *   @query({parameter: 'para'})\n *   @storage({key: 'storage_path'})\n *   @property({value: 1}) a;\n * }\n * const s = new S()\n * \n * localStorage.getItem('_ls_storage_path') \n * \n * ```\n * @param options \n * @returns \n */\nexport function query(options?: QueryOptions) {\n\n\treturn (\n\t\tproto: State,\n\t\tname: PropertyKey\n\t) => {\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(proto, name);\n\t\tif (!descriptor) {\n\t\t\tthrow new Error('@local-storage decorator need to be called after @property')\n\t\t}\n\t\tconst ctor = (proto).constructor as typeof State;\n\t\tconst parameter: string = `${options?.parameter || String(name)}`;\n\t\tconst definition = ctor.propertyMap.get(name);\n\t\tconst type = definition?.type\n\t\tif (definition) {\n\t\t\tconst previousValue = definition.initialValue\n\t\t\tconst parameterValue = url.searchParams.get(parameter)\n\n\t\t\t// register the fact that this property is set by a query parameter\n\t\t\tif (parameterValue !== null) {\n\t\t\t\tdefinition.skipAsync = true\n\t\t\t}\n\t\t\tdefinition.initialValue = () => parse(parameterValue, type) ?? functionValue(previousValue);\n\t\t\tctor.propertyMap.set(name, { ...definition, ...options })\n\n\t\t\treturn undefined\n\n\t\t}\n\t\treturn undefined\n\t}\n\n}\n\n"]}