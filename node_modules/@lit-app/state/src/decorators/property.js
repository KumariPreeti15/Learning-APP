export function property(options) {
    return (proto, name) => {
        if (Object.getOwnPropertyDescriptor(proto, name)) {
            throw new Error('@property must be called before all state decorators');
        }
        ;
        const ctor = (proto).constructor;
        ctor.initPropertyMap();
        const hasOwnProperty = proto.hasOwnProperty(name);
        ctor.propertyMap.set(name, {
            ...options,
            ...{ initialValue: options?.value, resetValue: options?.value }
        });
        ctor.createProperty(name, options);
        // For accessors (which have a descriptor on the prototype) we need to
        // return a descriptor, otherwise TypeScript overwrites the descriptor we
        // define in createProperty() with the original descriptor. We don't do this
        // for fields, which don't have a descriptor, because this could overwrite
        // descriptor defined by other decorators.
        // @ts-ignore
        return hasOwnProperty
            ? Object.getOwnPropertyDescriptor(proto, name)
            : undefined;
    };
}
//# sourceMappingURL=property.js.map