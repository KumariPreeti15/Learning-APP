{"version":3,"file":"property.js","sourceRoot":"","sources":["property.ts"],"names":[],"mappings":"AAwCA,MAAM,UAAU,QAAQ,CACtB,OAAyB;IAGzB,OAAO,CACL,KAAY,EACZ,IAAiB,EACX,EAAE;QAER,IAAI,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE;YAChD,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAA;SACxE;QAAA,CAAC;QACF,MAAM,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,WAA2B,CAAC;QACjD,IAAI,CAAC,eAAe,EAAE,CAAA;QACtB,MAAM,cAAc,GAAG,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAClD,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE;YACzB,GAAG,OAAO;YACV,GAAG,EAAE,YAAY,EAAE,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,OAAO,EAAE,KAAK,EAAE;SAChE,CAAC,CAAA;QACF,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAEnC,sEAAsE;QACtE,yEAAyE;QACzE,4EAA4E;QAC5E,0EAA0E;QAC1E,0CAA0C;QAC1C,aAAa;QACb,OAAO,cAAc;YACnB,CAAC,CAAC,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,IAAI,CAAC;YAC9C,CAAC,CAAC,SAAS,CAAC;IAChB,CAAC,CAAA;AAEH,CAAC","sourcesContent":["\nimport { State } from '../state.js'\n\nexport type PropertyTypes = Array<unknown> | Boolean | Object | String | Number\n/**\n * Defines options for a property.\n */\nexport type PropertyOptions = {\n\n  /**\n   * The value to initiate the state with\n   */\n  value?: unknown;\n\n  /**\n   * State.reset reset all property values to their initial {value: value}\n   * value. This is not the wanted behavior in some cases. For instance, we can\n   * have a state property for language, with an initial value (english). The \n   * state will be reset on user sign-out, but we want to keep the actual \n   * state value for language, if the user has modified it. \n   */\n  skipReset?: boolean\n\n  /** \n   * the type of the property. Used to Stringify/parse depending on wich \n   * other decorators are in use. For instance, @storage strignify before\n   * storing to localStorage. \n   */\n  type?: PropertyTypes;\n\n  /**\n   * A function that indicates if a property should be considered changed when\n   * it is set. The function should take the `newValue` and `oldValue` and\n   * return `true` if an update should be requested.\n   */\n  hasChanged?(value: unknown, oldValue: unknown): boolean;\n}\n\nexport type PropertySignature = (protoOrDescriptor: State, name?: string | undefined) => any\n\nexport function property(\n  options?: PropertyOptions,\n\n) {\n  return (\n    proto: State,\n    name: PropertyKey\n  ): void => {\n\n    if (Object.getOwnPropertyDescriptor(proto, name)) {\n      throw new Error('@property must be called before all state decorators')\n    };\n    const ctor = (proto).constructor as typeof State;\n    ctor.initPropertyMap()\n    const hasOwnProperty = proto.hasOwnProperty(name);\n    ctor.propertyMap.set(name, {\n      ...options,\n      ...{ initialValue: options?.value, resetValue: options?.value }\n    })\n    ctor.createProperty(name, options);\n\n    // For accessors (which have a descriptor on the prototype) we need to\n    // return a descriptor, otherwise TypeScript overwrites the descriptor we\n    // define in createProperty() with the original descriptor. We don't do this\n    // for fields, which don't have a descriptor, because this could overwrite\n    // descriptor defined by other decorators.\n    // @ts-ignore\n    return hasOwnProperty\n      ? Object.getOwnPropertyDescriptor(proto, name)\n      : undefined;\n  }\n\n}\n"]}