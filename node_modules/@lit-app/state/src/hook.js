const DONOTUSE = 'DONOTUSE';
/**
 * A base class for building state hooks
 */
class Hook {
    static { this.hookName = DONOTUSE; }
    constructor(state) {
        this.state = state;
        if (!this.constructor.hookName || this.constructor.hookName === DONOTUSE) {
            throw new Error('hook subclass must have their own hookName');
        }
        this.unsubscribe = this.subscribe();
        state.hookMap.set(this.constructor.hookName, this);
    }
    subscribe() {
        return this.state.subscribe(this.fromState.bind(this), this.hookedProps.map(([key]) => key));
    }
    get hookedProps() {
        const stateProto = Object.getPrototypeOf(this.state);
        if (!stateProto.propertyMap) {
            stateProto.initPropertyMap();
        }
        return [...stateProto.propertyMap].filter(([, definition]) => definition?.hook
            && definition?.hook[this.constructor.hookName]);
    }
    /**
     * Returns true if the key is configured for this hook
     * @param key
     * @returns boolean
     */
    isHookedProp(key) {
        return this.getDefinition(key)?.hook?.[this.constructor.hookName];
    }
    getDefinition(key) {
        return this.state.propertyMap.get(key);
    }
    toState(values) {
        Object.entries(values)
            .filter(([key]) => this.isHookedProp(key))
            .forEach(([key, value]) => this.state[key] = value);
    }
    // @ts-ignore 
    fromState(key, value, state) {
        throw ('fromState must be implemented in subclasses');
    }
    // @ts-ignore 
    reset() {
        throw ('reset hook must be implemented in subclasses');
    }
}
export { Hook };
//# sourceMappingURL=hook.js.map