class DragAndDropRowsController {
  #host;
  #tableRef;
  #tableBodyRef;
  #sourceIndex;
  #nestedDataExists;
  #sourceElement;
  #sourceHandle;
  constructor(host, tableRef, tableBodyRef, nestedDataExists) {
    this.#host = host;
    this.#tableRef = tableRef;
    this.#tableBodyRef = tableBodyRef;
    this.#nestedDataExists = nestedDataExists;
    this.#host.addController(this);
  }
  hostConnected() {
    this.#tableBodyRef.addEventListener("pointerdown", this.#handlePointerDown);
    this.#tableBodyRef.addEventListener("pointerup", this.#handlePointerUp);
  }
  hostDisconnected() {
    this.#tableBodyRef.removeEventListener("pointerdown", this.#handlePointerDown);
    this.#tableBodyRef.removeEventListener("pointerup", this.#handlePointerUp);
  }
  #handlePointerDown = (e) => {
    const target = e.target;
    const element = target.closest("tr");
    this.#sourceElement = element;
    this.#sourceHandle = target.closest("td");
    element.setAttribute("draggable", "true");
    this.#tableBodyRef.addEventListener("dragend", this.#handleDragEnd);
    this.#tableBodyRef.addEventListener("dragstart", this.#handleDragStart);
    this.#tableBodyRef.addEventListener("dragover", this.#handleDragOver);
    this.#tableBodyRef.addEventListener("dragleave", this.#handleDragLeave);
    this.#tableBodyRef.addEventListener("drop", this.#handleDrop);
  };
  #handlePointerUp = (e) => {
    this.#tableBodyRef.removeEventListener("dragend", this.#handleDragEnd);
    this.#tableBodyRef.removeEventListener("dragstart", this.#handleDragStart);
    this.#tableBodyRef.removeEventListener("dragover", this.#handleDragOver);
    this.#tableBodyRef.removeEventListener("dragleave", this.#handleDragLeave);
    this.#tableBodyRef.removeEventListener("drop", this.#handleDrop);
  };
  #handleDragEnd = (e) => {
    const element = e.target;
    element.style.opacity = "1";
    element.removeAttribute("draggable");
  };
  #handleDragStart = (e) => {
    const element = e.target;
    this.#sourceIndex = +element.getAttribute("drag-id");
    e.dataTransfer.effectAllowed = "move";
    element.style.opacity = "0.4";
    if (this.#nestedDataExists) this.#host.collapseAll();
  };
  #handleDragOver = (e) => {
    e.preventDefault();
    const target = e.target;
    const element = target.closest(".line-container");
    if (element) {
      const lineId = +element.getAttribute("line-id");
      if (this.#sourceIndex === lineId || this.#sourceIndex === lineId - 1) return;
      element.setAttribute("drag-over", "");
    }
  };
  #handleDragLeave = (e) => {
    e.preventDefault();
    const target = e.target;
    const element = target.closest(".line-container");
    if (element) {
      element.removeAttribute("drag-over");
    }
  };
  #handleDrop = async (e) => {
    e.preventDefault();
    e.stopPropagation();
    const target = e.target;
    if (this.#tableRef !== target.closest("table")) return;
    const element = target.closest(".line-container");
    if (element) {
      const lineId = +element.getAttribute("line-id");
      element.removeAttribute("drag-over");
      await Promise.all([
        this.#createDroppedElementAnimation(e, this.#sourceIndex, lineId),
        ...this.#createMovedElementsAnimation(e, this.#sourceIndex, lineId)
      ]);
      this.#updateData(this.#sourceIndex, lineId);
    }
  };
  #updateData(sourceId, destinationId) {
    if (sourceId < destinationId) destinationId--;
    this.#host.dispatchNewEvent("omni-drop", {
      detail: { moveFromIdx: this.#sourceIndex, moveToIdx: destinationId }
    });
  }
  #createMovedElementsAnimation(e, moveFromIdx, moveToIdx) {
    let moveToIndex = moveToIdx;
    const elements = this.#tableBodyRef.querySelectorAll("tr[drag-id]");
    const animationArray = [];
    if (moveFromIdx < moveToIdx) {
      moveToIndex--;
      for (let i = moveFromIdx + 1; i <= moveToIndex; i++) {
        const prevRect = elements[i - 1].getBoundingClientRect();
        const currentRect = elements[i].getBoundingClientRect();
        const diff = currentRect.top - prevRect.top;
        animationArray.push(
          elements[i].animate([{ transform: "translateY(0)" }, { transform: `translateY(-${diff}px)` }], {
            duration: 500,
            easing: "ease-in-out"
          }).finished
        );
      }
    } else {
      for (let i = moveFromIdx - 1; i >= moveToIdx; i--) {
        const nextRect = elements[i + 1].getBoundingClientRect();
        const currentRect = elements[i].getBoundingClientRect();
        const diff = nextRect.top - currentRect.top;
        animationArray.push(
          elements[i].animate([{ transform: "translateY(0)" }, { transform: `translateY(${diff}px)` }], {
            duration: 500,
            easing: "ease-in-out"
          }).finished
        );
      }
    }
    return animationArray;
  }
  #createDroppedElementAnimation(e, moveFromIdx, moveToIdx) {
    const sourceElementRect = this.#sourceElement.getBoundingClientRect();
    let moveToIndex = moveToIdx;
    if (moveFromIdx < moveToIdx) {
      moveToIndex--;
    }
    const elements = this.#tableBodyRef.querySelectorAll("tr[drag-id]");
    let targetEle;
    elements.forEach((element) => {
      if (element.getAttribute("drag-id") && +element.getAttribute("drag-id") === moveToIndex) {
        targetEle = element;
      }
    });
    const targetEleRect = targetEle.getBoundingClientRect();
    const diffTop = targetEleRect.top - sourceElementRect.top;
    return this.#sourceElement.animate([{ transform: "translateY(0)" }, { transform: `translateY(${diffTop}px)` }], {
      duration: 500,
      easing: "ease-in-out"
    }).finished;
  }
}
export {
  DragAndDropRowsController
};
//# sourceMappingURL=omni-drag-and-drop-rows.js.map
