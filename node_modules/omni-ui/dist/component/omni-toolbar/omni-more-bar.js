class MoreBar {
  constructor(barEl, moreEl, isJustifyEnd = false) {
    if (!barEl || !moreEl) throw new Error("MoreBar: two arguments required!");
    this.barEl = barEl;
    this.moreEl = moreEl;
    this.isJustifyEnd = isJustifyEnd;
  }
  init() {
    this.destroy();
    this.barEl.style.display = "flex";
    this.moreEl.style.position = "static";
    const marginPlusWidth = this.#getWidthPlusMargins(this.moreEl);
    this.#hideEl(this.moreEl);
    this.barEl.style.minWidth = `${marginPlusWidth}px`;
    const itemObserverOpts = {
      root: this.barEl,
      threshold: 0.99,
      // setup margin placeholder for more item
      rootMargin: this.isJustifyEnd ? `0px 0px 0px ${-marginPlusWidth}px` : `0px ${-marginPlusWidth}px 0px 0px`
    };
    const lastItemObserverOpts = {
      ...itemObserverOpts,
      rootMargin: "0px"
    };
    this._itemObserver = new IntersectionObserver(this.#onIntersection, itemObserverOpts);
    this._lastItemObserver = new IntersectionObserver(this.#onIntersection, lastItemObserverOpts);
    this.#observe();
  }
  destroy() {
    this.#unobserve();
  }
  #getWidthPlusMargins(el) {
    const style = getComputedStyle(el);
    const margins = {
      top: parseInt(style.marginTop, 10),
      right: parseInt(style.marginRight, 10),
      left: parseInt(style.marginLeft, 10),
      bottom: parseInt(style.marginBottom, 10)
    };
    return el.offsetWidth + margins.left + margins.right;
  }
  get #barItems() {
    let barChildArry;
    const bar = this.barEl;
    if (bar.matches("slot")) {
      barChildArry = bar.assignedElements();
    } else {
      barChildArry = Array.from(this.barEl.children);
    }
    const items = barChildArry.reduce((items2, child) => {
      if (child.matches("slot")) {
        items2 = items2.concat(child.assignedElements());
      } else if (child !== this.moreEl) {
        items2.push(child);
      }
      return items2;
    }, []);
    return this.isJustifyEnd ? items.reverse() : items;
  }
  get #firstHiddenItem() {
    for (const item of this.#barItems) {
      if (this.#isHidden(item)) return item;
    }
    return void 0;
  }
  #observe() {
    const barItems = this.#barItems;
    for (const item of barItems) {
      if (item !== barItems[barItems.length - 1]) {
        this._itemObserver.observe(item);
      } else {
        this._lastItemObserver.observe(item);
      }
    }
  }
  #unobserve() {
    this._itemObserver?.disconnect();
    this._lastItemObserver?.disconnect();
  }
  #isHidden(el) {
    return el?.style.visibility === "hidden";
  }
  #hideEl(el) {
    el.style.visibility = "hidden";
  }
  #showEl(el) {
    el.style.visibility = "visible";
  }
  #positionMoreItem() {
    this.#hideEl(this.moreEl);
    this.moreEl.style.transform = "";
    const firstHiddenItem = this.#firstHiddenItem;
    if (firstHiddenItem) {
      const side = this.isJustifyEnd ? "right" : "left";
      this.moreEl.style.transform = `
        translateX(${firstHiddenItem.getBoundingClientRect()[side] - this.moreEl.getBoundingClientRect()[side]}px)
      `;
      this.#showEl(this.moreEl);
      this.barEl.dispatchEvent(
        new CustomEvent("morebar-moreitem-show", {
          bubbles: true,
          detail: {
            item: this.moreEl,
            type: "show",
            transform: this.moreEl.style.transform,
            moreBar: this
          }
        })
      );
    }
  }
  #onIntersection = (entries) => {
    for (const entry of entries) {
      let isShow;
      if (entry.isIntersecting) {
        this.#showEl(entry.target);
        isShow = true;
      } else {
        this.#hideEl(entry.target);
        isShow = false;
      }
      this.barEl.dispatchEvent(
        new CustomEvent("morebar-item-update", {
          bubbles: true,
          detail: {
            item: entry.target,
            type: isShow ? "show" : "hide",
            index: this.#barItems.indexOf(entry.target),
            moreBar: this
          }
        })
      );
    }
    this.#positionMoreItem();
  };
}
export {
  MoreBar
};
//# sourceMappingURL=omni-more-bar.js.map
