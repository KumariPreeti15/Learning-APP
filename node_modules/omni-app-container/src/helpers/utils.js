/**
 * @namespace utils
 * @description Utils used by multiple components/modules
 */

// NOTE: Everything in here should be standalone. Do not import from elsewhere.
// This is to ensure if any consuming apps use these functions they will work properly.

/**
 * Treat local environment as dev, all others are themselves
 */
export const ssoEnv = env => (env === 'local' ? 'dev' : env);

/**
 * Determine the hostname given a base hostname and env.
 * "local" + "omni.annalect.com" => "devomni.annalect.com"
 * Optional third argument allows overriding the result when environment is local.
 */
export const ssoHost = (env, host, localHostname) => {
  if (env === 'local' && localHostname) return localHostname;
  let prefix = ssoEnv(env);
  if (prefix === 'prod') prefix = '';
  return `${prefix}${host}`;
};

export const envFromHostname = (hostname = window.location.hostname) => {
  if (hostname === 'localhost.annalect.com') return undefined;
  const match = hostname.match(/^(dev|qa|stg|).*\.annalect\.com$/);
  if (!match) return undefined;
  return match[1] || 'prod';
};

export const fetchOmni = async (env, path, options) => {
  // fetchJSON fails as it adds headers rejected by CORS; using fetch directly
  const url = `https://${ssoHost(env, 'omni.annalect.com')}${path}`;
  const response = await fetch(url, options);
  return response.json();
};

export const isLocal = [
  'localhost',
  '127.0.0.1',
  '0.0.0.0',
  'localhost.annalect.com',
].includes(window.location.hostname.toLowerCase());

export const isIframe = window.location !== window.parent.location;

export const now = () => new Date().getTime();

export const parseJWT = token => {
  const base64Url = token.split('.')[1];
  const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
  const jsonPayload = decodeURIComponent(
    window
      .atob(base64)
      .split('')
      .map(c => `%${`00${c.charCodeAt(0).toString(16)}`.slice(-2)}`)
      .join('')
  );
  return JSON.parse(jsonPayload);
};

export const jwtExpirationMs = token => {
  const expiration = parseJWT(token).exp * 1000; // timestamp in ms
  const relative = expiration - now();
  return relative;
};

export const userHasRole = (jwt, typeKey, requiredRoles) => {
  try {
    const { omniTypeKeys, roles } = parseJWT(jwt);
    const appIndex = omniTypeKeys?.indexOf(typeKey);
    // Get user roles for this app
    const userRoles = roles?.[appIndex]?.split(',') ?? [];
    // Intersect with list of roles required for this app
    const matches = userRoles.filter(x => requiredRoles.includes(x));
    return matches.length > 0;
  } catch {
    return false;
  }
};

export const envHasCorsError = async env => {
  // Only worry about qa/stg/prod; dev and local we can assume to work.
  if (['dev', 'local'].includes(env)) return false;

  try {
    const path = `/am/amapi/user/session/not-a-real-ansid`;
    const url = `https://${ssoHost(env, 'omni.annalect.com')}${path}`;
    const response = await fetch(url);
    if (response.status === 404) {
      // Expected response no CORS error
      return false;
    }
    throw new Error(
      `Unexpected response while testing (${env} omni): ${JSON.stringify(
        response
      )}`
    );
  } catch (e) {
    // CORS error throws exception
    return true;
  }
};

export const portalLogin = (env, resourceKey) => {
  if (isIframe) {
    // Send message to parent window (portal) to re-login
    const msg = {
      type: 'validateAuthentication',
      _protocol: 'OFM-1.3.0',
    };
    const targetOrigin = `https://${ssoHost(env, 'omni.annalect.com')}`;
    window.parent.postMessage(msg, targetOrigin);
  } else {
    // No iframe => load portal redirect login
    const redirectURL = encodeURIComponent(window.location.href);
    const host = ssoHost(env, 'omni.annalect.com');
    const loginURL = `https://${host}/extsso?resourcekey=${resourceKey}&redirecturl=${redirectURL}`;
    window.location.href = loginURL;
  }
};
