import { ssoEnv, fetchOmni, parseJWT, jwtExpirationMs } from './utils.js';

export class SessionCache extends EventTarget {
  #storeName = 'app-container-cache';

  #cache = {};

  #pendingDispatch;

  #refreshInterval;

  constructor() {
    super();
    this.loadLocalStorage();
  }

  /**
   * Dispatch change event on next call stack. Batch all changes from the same call
   * stack into one event.
   *
   */
  scheduleCacheChangeEvent() {
    if (this.#pendingDispatch) return;
    this.#pendingDispatch = true;
    setTimeout(() => {
      this.dispatchEvent(new Event('cache-change'));
      this.#pendingDispatch = false;
    }, 0);
  }

  init(env, client, resourceKey) {
    // Load and apply localstorage first then override with passed values
    this.loadLocalStorage();

    this.#cache.env = env || this.#cache.env || 'dev';
    this.#cache.resourceKey = resourceKey ?? 'omni_app_container';
    if (client) {
      this.activeClientUuid = client;
    }
    this.postInit();
  }

  postInit() {
    if (this.ANsid && this.env && this.profile?.clients) {
      const exists = clientId =>
        clientId && this.profile.clients.some(c => c.clientId === clientId);
      if (!exists(this.activeClientUuid)) {
        // Set client to last used client or first one in profile
        this.activeClientUuid = exists(this.#cache.lastClientUuid)
          ? this.#cache.lastClientUuid
          : this.profile.clients[0].clientId;
      }
    }

    // Reset JWT if its internal client id doesn't match current client id
    if (
      this.#cache.token &&
      this.activeClientUuid &&
      parseJWT(this.#cache.token).client_guid !== this.activeClientUuid
    ) {
      delete this.#cache.token;
    }

    this.#setWindowProperty();
    this.save();
  }

  getLocalStorage(key) {
    const storage = localStorage.getItem(this.#storeName);
    if (!storage) return undefined;
    const parsed = JSON.parse(storage);
    return key ? parsed[key] : parsed;
  }

  loadLocalStorage() {
    const storage = this.getLocalStorage();
    if (storage) {
      const ansidChange = this.#cache?.ANsid !== storage.ANsid;
      this.#cache = storage;
      if (ansidChange) this.startANsidRefresh(true);
    }
  }

  setCache(ANsid, env, profile) {
    // Don't reset the client, and only reset token if env changes
    if (ssoEnv(env) !== ssoEnv(this.env)) delete this.#cache.token;

    // Reset JWT if its internal ANsid doesn't match the ANsid being set
    if (this.#cache.token && parseJWT(this.#cache.token).ANsid !== ANsid) {
      delete this.#cache.token;
    }

    this.#cache.ANsid = ANsid;
    this.#cache.env = env;
    this.#cache.profile = profile;
    this.postInit();
    this.startANsidRefresh();
  }

  startANsidRefresh(immediate = false) {
    // Not ready yet, this function will get called again when we set the ANsid
    if (!this.ANsid) return;

    const interval = 30 * 60 * 1000; // 30 minutes (in milliseconds)

    const refresh = async () => {
      let isAuthorized = false;
      try {
        // Check and refresh ANsid
        const path = `/am/amapi/user/session/${this.ANsid}`;
        const response = await fetchOmni(this.env, path);
        // Explicit test against true to workaround weird response from API.
        // API returns boolean (true) and string ("false") TODO: fix in future
        isAuthorized = response.isAuthorized === true;
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error(
          'Failed to check/refresh ANsid, probably CORS a issue!',
          e
        );
        // Don't trigger redirect as that might result in a redirect loop
        return;
      }

      if (!isAuthorized) {
        // eslint-disable-next-line no-console
        console.log('Detected expired session, refreshing');
        this.clearCache();
        return;
      }

      // Also check if JWT is expiring soon
      if (this.token) {
        if (jwtExpirationMs(this.token) < 2 * interval) {
          // Will expire within 2 intervals, be safe and refresh jwt now
          // eslint-disable-next-line no-console
          console.log('Detected JWT will expire soon, refreshing');
          delete this.#cache.token;
          this.save();
        }
      }
    };

    if (immediate) refresh();
    clearInterval(this.#refreshInterval);
    this.#refreshInterval = setInterval(refresh, interval);
  }

  clearCache(newEnv, dispatch = true) {
    clearInterval(this.#refreshInterval);

    this.#cache = {
      env: newEnv ?? this.env,
      activeClientUuid: this.activeClientUuid,
    };
    this.save();
    if (dispatch) this.dispatchEvent(new Event('cache-cleared'));
  }

  save() {
    // Detect weird behavior where the environment gets set to something wrong
    if (this.env && !['local', 'dev', 'qa', 'stg', 'prod'].includes(this.env)) {
      throw new Error(
        `Invalid environment: ${this.env}. Report stacktrace to omni-app-container team.`
      );
    }

    localStorage.setItem(
      this.#storeName,
      JSON.stringify({
        // Environment and client should never get cleared from local storage
        env: this.env ?? this.getLocalStorage('env'),
        lastClientUuid:
          this.activeClientUuid ?? this.getLocalStorage('lastClientUuid'),
        ANsid: this.ANsid,
        profile: this.profile,
        token: this.token,
      })
    );

    this.scheduleCacheChangeEvent();
  }

  #setWindowProperty() {
    // Make sso info accessible on the window object similar to portal
    if (!window.AN) window.AN = {};

    // More or less the same fields that are set by portal
    const fields = [
      'fullName',
      'firstName',
      'languageKey',
      'lastName',
      'orgName',
      'themeKey',
      'email',
      'personId',
      'userImage',
      'clients',
    ];
    const miniProfile = Object.fromEntries(
      Object.entries(this.#cache.profile ?? {}).filter(([key]) =>
        fields.includes(key)
      )
    );

    // Also add projects to the user profile, with a subset of what is available
    // in portal. It's important we never have more than portal, less is ok. We
    // can always add missing fields as needed.
    const projectFields = [
      'clientId',
      'externalIdentifier',
      'projectId',
      'projectName',
      'typeKey',
      'userRoles',
    ];
    miniProfile.projects = (this.#cache.profile?.projects ?? []).map(project =>
      Object.fromEntries(
        Object.entries(project ?? {}).filter(([key]) =>
          projectFields.includes(key)
        )
      )
    );

    window.AN.sso = {
      session: { sid: this.#cache.ANsid, env: this.#cache.env },
      user: miniProfile,
    };
  }

  get ANsid() {
    return this.#cache.ANsid;
  }

  get env() {
    return this.#cache.env;
  }

  get resourceKey() {
    return this.#cache.resourceKey;
  }

  get profile() {
    return this.#cache.profile;
  }

  get activeClient() {
    return this.profile?.clients?.find(
      c => c.clientId === this.activeClientUuid
    );
  }

  get activeClientName() {
    return this.#cache.activeClient?.orgName;
  }

  get activeClientUuid() {
    return this.#cache.activeClientUuid;
  }

  set activeClientUuid(activeClientUuid) {
    this.#cache.activeClientUuid = activeClientUuid;
    this.save();
  }

  get token() {
    return this.#cache.token;
  }

  set token(token) {
    this.#cache.token = token;
    this.save();
  }

  get activeClientImage() {
    return this.#cache.activeClient?.urlLogo;
  }

  get firstName() {
    return this.#cache.profile?.firstName;
  }

  get lastClientUuid() {
    return this.#cache.lastClientUuid;
  }
}
