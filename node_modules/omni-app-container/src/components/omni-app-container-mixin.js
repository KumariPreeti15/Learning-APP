/* This mixin is used by apps hosted in portal and should *only* import omni-ui */

import { ContextConsumerMixin } from 'omni-ui';

const contextKeys = [
  'ANsid',
  'clientId',
  'env',
  'profile',
  'readonly',
  'token',
  'router',
];
const inContext = Object.fromEntries(contextKeys.map(x => [x, true]));

/**
 * Apps can use this mixin for components that want to:
 *  1. Navigate to other routes in the app
 *  2. Get context data (as properties)
 *  3. Get route params (as properties)
 *
 * The context is also available in this.context and for apps that just want to get
 * updated when the context as a whole changes, they can create a "context" property as
 * normal with OmniElement/lit.
 *
 * Router location info is set on this.location if this component is created with the
 * vaadin router.
 *
 * Example:
 *
 *
 * class MyApp extends OmniAppContainerMixin(OmniElement) {
 *   static get properties() {
 *     return {
 *       // normal properties
 *       name: { type: String },
 *
 *       // Comes from context
 *       env: this.contextProperty({ name: "env" }),
 *       clientId: this.contextProperty({ name: "clientId" }),
 *
 *       // Comes from location route params (renamed)
 *       objectId: this.routeParamProperty({ name: "objectId", source: "object" }),
 *     }
 *   }
 *
 *   updated(changedProperties) {
 *     if (changedProperties.has('env') || changedProperties.has('objectId')) {
 *       // do something
 *     }
 *   }
 *
 *   handleWhateverEvent() {
 *      this.navigateTo('another/route');
 *   }
 * }
 */
export const OmniAppContainerMixin = SuperClass => {
  // These are being used as private "static" fields not accessible to the child class.
  const contextProperties = {};
  const routeParamProperties = {};

  return class AppContainerElement extends ContextConsumerMixin(SuperClass) {
    #routerLocation;

    #disconnected;

    constructor() {
      super();
      this.onRouterLocationChanged = this.onRouterLocationChanged.bind(this);
    }

    static contextProperty({ name, source, options = {} }) {
      const contextKey = source ?? name;
      if (!inContext[contextKey])
        throw new Error(`Invalid context: ${contextKey}`);
      contextProperties[contextKey] = name;
      return { attribute: false, ...options };
    }

    static routeParamProperty({ name, source, options = {} }) {
      const paramName = source ?? name;
      routeParamProperties[paramName] = name;
      return { attribute: false, ...options };
    }

    connectedCallback() {
      super.connectedCallback();
      window.addEventListener(
        'vaadin-router-location-changed',
        this.onRouterLocationChanged
      );
    }

    disconnectedCallback() {
      this.#disconnected = true;
      window.removeEventListener(
        'vaadin-router-location-changed',
        this.onRouterLocationChanged
      );
      super.disconnectedCallback();
    }

    // Child classes should call this to navigate to their own relative urls (no leading
    // '/'). In the case of routing between apps for example or to a different client,
    // an absolute url can be passed (starting with '/').
    navigateTo(url) {
      this.dispatchNewEvent('omni-router-navigate-to', { detail: { url } });
    }

    async onRouterLocationChanged(e) {
      const { params } = e.detail.location;
      // Try to avoid firing change events when the component is about to be
      // disconnected. Waiting for three ticks to complete before checking if we're
      // disconnected appears to address this race condition under normal circumstances.
      await null;
      await null;
      await null;
      if (!this.#disconnected) {
        Object.entries(routeParamProperties).forEach(
          ([paramName, propName]) => {
            this[propName] = params[paramName];
          }
        );
      }
    }

    onContextChanged() {
      // Need to trigger onRouterLocationChanged when initializing even if the location
      // didn't change from the router's perspective.
      if (!this.#routerLocation && this.context.router?.location) {
        this.#routerLocation = this.context.router.location;
        this.onRouterLocationChanged({
          detail: { location: this.#routerLocation },
        });
      }

      if (Object.keys(contextProperties).length) {
        // Update all configured context properties
        Object.entries(contextProperties).forEach(([contextKey, propName]) => {
          this[propName] = this.context[contextKey];
        });
      } else {
        // Trigger a re-render if no context properties are set
        this.requestUpdate('context');
      }
    }
  };
};
