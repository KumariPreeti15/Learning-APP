import {
  OmniElement,
  OmniStyleElement,
  OmniTooltipElement,
  nothing,
  html,
  css,
  classMap,
  ifDefined,
} from 'omni-ui';

import { selectBucketedClients } from '../helpers/selectors.js';
import { generateToken } from '../helpers/token.js';

OmniStyleElement.register();
OmniTooltipElement.register();

export class OmniAppContainerClientSelectionMenu extends OmniElement {
  static get properties() {
    return {
      clients: { type: Array },
      activeClient: { type: String },
      session: { type: Object },

      isOpen: { state: true },
      activeSubmenu: { state: true },
      isLoading: { state: true },
    };
  }

  static get styles() {
    return [
      super.styles,
      css`
        :host {
          display: flex;
          justify-content: flex-start;
          align-items: center;
        }

        [hidden] {
          display: none !important;
        }
        .hidden {
          visibility: hidden;
        }
        .dropdown {
          width: 17.86rem;
        }
        .dropdown-menu {
          padding-top: 0 !important;
        }
        .dropdown-menu.has-nested-menu {
          margin-top: 0.43rem;
        }
        .toolbar {
          height: 2.86rem;
          background-color: #fff !important;
          border-top-left-radius: 0.57rem;
          border-top-right-radius: 0.57rem;
          box-shadow: rgba(10, 10, 10, 0.1) 0 0.5em 1rem -0.125em,
            rgba(10, 10, 10, 0.02) 0 0 0 1px;
          text-align: right !important;
        }

        /* not sure why but omni-ui is very specifically making this 0px wide */
        .omni button.button.is-rounded {
          width: auto;
          cursor: pointer;
        }

        omni-tooltip::part(tooltip) {
          line-height: 16px !important;
        }
        .dropdown-content {
          max-height: 191px;
          overflow-y: auto;
        }
        .dropdown-trigger omni-icon[icon-id='omni:interactive:up'] {
          fill: white !important;
        }
        .dropdown-menu.has-nested-menu > .dropdown-content {
          border-top-left-radius: 0 !important;
          border-top-right-radius: 0 !important;
          box-shadow: rgba(10, 10, 10, 0.1) 0 0.5em 5px;
        }
        .dropdown-item {
          display: flex !important;
          flex-direction: row;
          align-items: center;
          height: 36px;
        }
        .dropdown-item:focus {
          background-color: rgba(77, 197, 252, 0.14) !important;
        }
        .dropdown-item > p {
          pointer-events: none;
        }
        .checkmark {
          width: 16px;
          margin-right: 4px;
          pointer-events: none;
          flex-shrink: 0;
          fill: var(--color-electric-blue);
        }
        .submenu-arrow {
          width: 16px;
          height: 16px;
          position: absolute;
          right: 10px;
        }
        .nested.dropdown {
          width: 100%;
        }
        .nested.dropdown .dropdown-trigger {
          width: 100%;
        }
        .nested.dropdown .dropdown-menu {
          position: fixed;
          top: -9999px;
          left: -9999px;
          /* next 3 CSS rules should be propogated to CSS framework */
          padding-top: 0 !important;
          box-shadow: 0 13px 54px -11px rgba(1, 33, 78, 0.7);
          border-radius: 8px;
        }
        .dropdown.is-active .nested.dropdown .dropdown-menu {
          display: none;
        }
        .dropdown.is-active .nested.dropdown.is-active .dropdown-menu,
        .dropdown.is-active .nested.dropdown.is-hoverable:hover .dropdown-menu {
          display: block;
        }
        .letter-icon {
          flex-shrink: 0;
          width: 24px;
          height: 24px;
          margin-right: 7px;
          background: rgb(255, 255, 255);
          border: 1px solid var(--color-electric-blue);
          border-radius: 50%;
          color: var(--color-electric-blue);
          line-height: 20px;
        }
      `,
    ];
  }

  connectedCallback() {
    super.connectedCallback();
    document.addEventListener('click', this._handleDocumentClick);
    this.session.addEventListener('cache-change', async () => {
      if (
        this.session.env &&
        this.session.ANsid &&
        this.session.activeClientUuid &&
        !this.session.token
      ) {
        const tokenInfo = `${this.session.env}:${this.session.activeClientUuid}`;
        // Avoid multiple calls to generate the same token
        if (this.tokenLoading === tokenInfo) return;

        this.tokenLoading = tokenInfo;
        this.session.token = await generateToken(
          this.session.env,
          this.session.activeClientUuid,
          this.session.ANsid,
          this.session.resourceKey
        );
        this.tokenLoading = null;
      }
    });
  }

  disconnectedCallback() {
    document.removeEventListener('click', this._handleDocumentClick);
    super.disconnectedCallback();
  }

  _handleDocumentClick = e => {
    const path = e.composedPath();

    if (
      !path.includes(this.shadowRoot.querySelector('omni-style')) &&
      this.isOpen
    ) {
      this._toggleMenu();
    }
  };

  _toggleMenu = () => {
    this.isOpen = !this.isOpen;

    if (!this.isOpen) {
      this.activeSubmenu = null;
    }
  };

  async _onClientSelect(e, client) {
    const { children, clientId } = client;
    if (
      e.clientX !== undefined ||
      (e.keyCode !== undefined && e.keyCode === 13) ||
      e.keyCode === 32
    ) {
      const isParent = !!children?.length;

      if (isParent) {
        this._positionSubmenu(e);
        // toggle submenu if this is a parent client
        this._setSubmenu(clientId);
      } else if (this.activeClient === clientId) {
        // do nothing if re-selecting selected item
        this.isOpen = false;
      } else {
        // generate token & change client
        this.isOpen = false;
        this.isLoading = true;

        try {
          const token = await generateToken(
            this.session.env,
            clientId,
            this.session.ANsid,
            this.session.resourceKey
          );
          this.session.activeClientUuid = client.clientId;
          this.session.token = token;
        } finally {
          this.isLoading = false;
        }
      }

      if (!isParent) this._setSubmenu();
    }
  }

  _setSubmenu(id) {
    this.activeSubmenu = id || null;
  }

  // function used to position submenus of dropdowns
  // eslint-disable-next-line class-methods-use-this
  _positionSubmenu = e => {
    const composed = e.composedPath();
    let parent = null;
    for (const elem of composed) {
      // submenus will have a div.nested.dropdown parent element
      if (elem.tagName === 'DIV' && elem.classList.contains('nested')) {
        parent = elem;
        break;
      }
    }
    const target = parent.querySelector('.dropdown-menu');
    const {
      right: parentRight,
      left: parentLeft,
      top: parentTop,
    } = parent.getBoundingClientRect();
    const { clientWidth: docWidth } = document.documentElement;
    const padding = 7;

    target.style.top = `${parentTop - padding}px`;
    target.style.right = 'auto';
    // position submenu on the left side if it overflows the window width
    if (parentRight + target.offsetWidth > docWidth) {
      target.style.left = `${parentLeft - target.offsetWidth}px`;
    } else {
      target.style.left = `${parentLeft + parent.offsetWidth}px`;
    }
  };

  /* eslint-disable lit-a11y/anchor-is-valid */
  _renderClientLink(c) {
    const hasChildren = !!c.children?.length;
    // If selected or child is selected
    const showCheck = hasChildren
      ? c.children?.filter(child => child.clientId === this.activeClient).length
      : c.clientId === this.activeClient;
    const handleSelect = e => {
      this._onClientSelect(e, c);
    };

    return html`
      <a
        class="dropdown-item"
        tabindex="0"
        @click=${handleSelect}
        @keydown=${handleSelect}
        role=${ifDefined(!hasChildren ? 'option' : undefined)}
        aria-selected=${this.activeClient === c.clientId}
        aria-haspopup=${ifDefined(hasChildren ? 'true' : undefined)}
        aria-controls=${ifDefined(hasChildren ? 'dropdown-menu' : undefined)}
      >
        <omni-icon
          class=${classMap({
            checkmark: true,
            'is-size-2': true,
            hidden: !showCheck,
          })}
          icon-id="omni:informative:check"
        ></omni-icon>
        <p>${c.orgName}</p>
        ${c.children?.length
          ? html`<omni-icon
              class="submenu-arrow is-size-2"
              icon-id="omni:interactive:right"
            ></omni-icon>`
          : null}
      </a>
    `;
  }
  /* eslint-enable lit-a11y/anchor-is-valid */

  get bucketedClients() {
    return selectBucketedClients(this.clients);
  }

  // eslint-disable-next-line class-methods-use-this
  _renderClients(clients = this.bucketedClients) {
    return html`
      <ul>
        ${clients.map(
          c => html`
            <li>
              ${c.children?.length
                ? html`
                    <div
                      class="nested dropdown ${classMap({
                        'is-active': this.activeSubmenu === c.clientId,
                      })}"
                    >
                      <div class="dropdown-trigger">
                        ${this._renderClientLink(c)}
                      </div>
                      <div
                        class="dropdown-menu"
                        id="dropdown-menu"
                        role="listbox"
                      >
                        <div class="dropdown-content">
                          ${this._renderClients(c.children)}
                        </div>
                      </div>
                    </div>
                  `
                : this._renderClientLink(c)}
            </li>
          `
        )}
      </ul>
    `;
  }

  render() {
    const currentClient = this.clients?.find(
      c => c.clientId === this.activeClient
    );
    const buttonClasses = {
      button: true,
      'is-rounded': true,
      'is-text': true,
      'is-capitalized': true,
      'is-size-3': true,
      'has-text-weight-semibold': true,
      'has-text-almost-black': !this.isOpen,
      'is-primary': this.isOpen,
      'has-text-white': this.isOpen,
    };

    return html`
      <omni-style>
        <div class="dropdown ${classMap({ 'is-active': this.isOpen })}">
          <div
            class="dropdown-trigger ${classMap({
              skeleton: !currentClient || this.isLoading,
            })}"
          >
            <button class=${classMap(buttonClasses)} @click=${this._toggleMenu}>
              <figure class="image is-24x24 mr-2">
                ${currentClient?.urlLogo?.match(/^https?:/i)
                  ? html` <img
                      class="is-rounded"
                      src="${currentClient?.urlLogo}"
                      alt="selected client logo"
                    />`
                  : html`
                      <div class="letter-icon size-3">
                        ${currentClient?.orgName?.[0]}
                      </div>
                    `}
              </figure>
              ${currentClient?.orgName}
              ${this.clients?.length
                ? html`<omni-icon
                    class="is-size-1 ml-3 ${classMap({
                      'has-text-white': this.isOpen,
                      'has-text-almost-black': !this.isOpen,
                    })}"
                    icon-id="${this.isOpen
                      ? 'omni:interactive:up'
                      : 'omni:interactive:down'}"
                  ></omni-icon>`
                : nothing}
            </button>
          </div>
          <div class="dropdown-menu has-nested-menu" role="listbox">
            <div class="dropdown-content" tabindex="-1">
              ${this._renderClients()}
            </div>
          </div>
        </div>
      </omni-style>
    `;
  }
}

OmniElement.register(
  'omni-app-container-client-selection-menu',
  OmniAppContainerClientSelectionMenu
);
